#
# $Id$
#
# Part of Equinox Desktop Environment (EDE).
# Copyright (c) 2000-2006 EDE Authors.
#
# This program is licenced under terms of the 
# GNU General Public Licence version 2 or newer.
# See COPYING for details.

# a base for Jamfile

# Intel CC
if $(ICC)
{
	CC      = /opt/intel/bin/icc ;
	C++     = /opt/intel/bin/icc ;
	LINK    = /opt/intel/bin/icc ;
	STDHDRS = /opt/intel/include ;
}

# directories
PREFIXDIR 		= @prefix@ ;
BINDIR    		= $(PREFIXDIR)/bin ;
DATADIR  		= $(PREFIXDIR)/share ; 
ICONSDIR        = $(DATADIR)/ede/icons ;
DOCSDIR         = $(DATADIR)/ede/doc ;
CONFDIR         = $(DATADIR)/ede/.ede ;

# needed variables
INSTALL			= @INSTALL@ ;
INSTALL_PROGRAM = $(INSTALL) ;
INSTALL_DATA	= $(INSTALL) -m 644 ;
MSGFMT			= @MSGFMT@ ;

OPTIM     		= ;
C++FLAGS 		= -DSHAPE @CXXFLAGS@ ;
LINKLIBS  		= @LIBS@ ;

actions quietly Help
{
	echo ""
	echo "Options:"
	echo "   jam              build everything"
    echo "   jam [target]     build [target]"
    echo "   jam install      install all (needs to be a root)"
    echo "   jam uninstall    oposite of install"
    echo "   jam clean        clean all"
    echo ""
}
Help help ;

NOTFILE help ;
ALWAYS help ;
NOUPDATE help ;

# InstallProgram DIRECTORY : target ;
rule InstallProgram
{
	local t ;
	t = $(>:BSR=$(<):G=installed) ;

	# create directory if does not exists
	MkDir $(<) ;

	DEPENDS install : $(t) ;
	DEPENDS $(t) : $(<) $(>) ;
	InstallProgram1 $(t) : $(>) ;

	# remove file from binpath/filename
	Clean uninstall : $(t) ;
}

actions quietly InstallProgram1
{
	echo "InstallProgram $(>)" 
	$(INSTALL_PROGRAM) $(>) $(<)
}

# InstallImagesFromDirectory TARGET_DIRECTORY : SOURCE_DIRECTORY ;
#
# Since ftjam don't have implemented GLOB, the only way
# to populate data from some directory is to use shell for it.
rule InstallImages
{
	local t t1 ;
	t = $(>:BSR=$(<):G=installed) ;

	MkDir $(<) ;

	DEPENDS install : $(t) ;
	DEPENDS $(t) : $(<) $(>) ;
	InstallImages1 $(t) : $(>) ;

	CleanDir uninstall : $(<) ;
}

# Since we get via $(t) pseudofile at the end
# $(<:D) will remove that part and populate data to
# the directory base.
actions quietly InstallImages1
{
	all=`find $(>) -name "*.png"`
	for i in $all; do
		echo "InstallImages $i $(<:D)"
		$(INSTALL_DATA) $i $(<:D)
	done
}

# InstallData DIRECTORY : targets ;
rule InstallData
{
	local t i ;

	MkDir $(<) ;

	for i in [ FGristFiles $(>) ]
	{
		t = $(i:BSR=$(<):G=installed) ;

		DEPENDS install : $(t) ;
		DEPENDS $(t) : $(<) $(i) ;
		InstallData1 $(t) : $(i) ;

		Clean uninstall : $(t) ;
	}
}

actions quietly existing InstallData1
{
	echo "InstallData $(>)"
	$(INSTALL_DATA) $(>) $(<)
}

actions piecemeal together existing CleanDir
{
	$(RM) -R $(>) ;
}

# Translation DIRECTORY : pofile ;
rule Translation
{
	local mofile pofile i ;

	for i in $(>)
	{
		pofile = [ FDirName $(<) $(i) ] ;
		mofile = [ FDirName $(<) $(i:S=.mo) ] ;

		DEPENDS $(mofile) : $(pofile) ;
		DEPENDS all : $(mofile) ;
		Translation1 $(mofile) : $(pofile) ;

		Clean clean : $(mofile) ;
	}
}

actions quietly Translation1
{
	echo "Translation $(>)"
	$(MSGFMT) $(>) -o $(<)
}

# Build DIRECTORY : target : sources ;
rule Build
{
	local dir = $(1) ;
	local target = [ FDirName $(dir) $(2) ] ;
	local to_build ;
	local other ;

	DEPENDS $(2) : $(target) ;

	# build a list of files
	for i in $(3)
	{
		if $(i:D) = ""
		{
			to_build += [ FDirName $(dir) $(i) ] ;
		}
		else
		{
			# assume we have already cooked files
			other += $(i) ;
		}
	}

	# append to global C++FLAGS
	C++FLAGS on $(to_build:S=$(SUFOBJ)) = -I$(dir)/ ;

	Objects $(to_build) ;
	MainFromObjects $(target) : $(to_build:S=$(SUFOBJ)) $(other:S=$(SUFOBJ)) ;
	InstallProgram $(BINDIR) : $(target) ;
}
