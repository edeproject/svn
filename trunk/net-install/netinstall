#!/usr/bin/env python

# Note: patches (for patching part in this program) should be generated in form:
# 'diff -uNr efltk/ efltksvn/ > efltk-2.0.6.patch'

import sys
import os
import md5
import urllib
import tarfile
import ConfigParser

__author__  = "Sanel Zukan <karijes@users.sourceforge.net>"
__version__ = "1.0"

# from where to download config files
netinstall_cfg_url = "http://equinox-project.org/netinstall-configs"

# some mutable globals
mirrors_url = []
patches_url = None

class Module:
	"""The class that represents each item that will be downloaded, compiled and installed."""
	def __init__(self):
		self.name = None
		self.package = None
		self.checksum = None
		self.patch = None
		self.url = None
		self.configure_flags = None
		self.no_configure = False

		# module will not be compiled if this executable was found
		self.skip_if_found = False

		# default
		self.configure_cmd = "./configure"
		self.compile_cmd   = "make"
		self.install_cmd   = "make install"

	def print_details(self):
		"""Display module details."""
		print "name              : %s" % self.name
		print "archive           : %s" % self.package
		print "checksum          : %s" % self.checksum
		print "patch             : %s" % self.patch
		print "configure flags   : %s" % self.configure_flags
		print "configure command : %s" % self.configure_cmd
		print "compile command   : %s" % self.compile_cmd
		print "install command   : %s" % self.install_cmd

	def print_short_info(self):
		"""Display module short info."""
		print " %s (%s)" % (self.name, self.package)


def do_message(msg, is_head = False):
	"""Prints a message."""
	if is_head:
		print("* %s" % msg)
	else:
		print("  %s" % msg)

def do_error(err, quit = True):
	"""Prints error message and quits."""
	print("*** %s" % err)
	if quit:
		sys.exit(1)

def file_remove(file):
	"""Remove file if exists; if not, do nothing."""
	try:
		os.unlink(file)
	except OSError:
		pass

def file_exists(file):
	"""Check if file exists and can be read."""
	return os.access(file, os.F_OK | os.R_OK)

def in_path(file):
	"""Check if file is in PATH."""
	lst = os.environ["PATH"].split(":")
	for l in lst:
		path = "%s/%s" % (l, file)
		if os.access(path, os.F_OK | os.X_OK):
			return True
	return False

def download_from(url, save_as, show_progress = True):
	"""Download from the given url."""

	if show_progress:
		# A callback for urllib.urlretrieve()
		def download_report_hook(transfered, block_size, total):
			print "\r  [%i B, total: %i B]" % (transfered, total),

	try:
		if show_progress:
			urllib.urlretrieve(url, save_as, download_report_hook)
		else:
			urllib.urlretrieve(url, save_as)
		print ""
	except IOError, e:
		do_error("Unable to download '%s'. Got: %s" % (save_as, e))

def fetch_and_parse_config(config_name, is_local):
	"""Download config file and parse it."""
	global mirrors_url
	global patches_url

	# default is to download it
	if not is_local:
		path = "%s/%s" % (netinstall_cfg_url, config_name)
		download_from(path, config_name, False)

	config = ConfigParser.ConfigParser()

	try:
		config.read(config_name)
	except ConfigParser.MissingSectionHeaderError, err:
		file_remove(config_name)
		do_error("Fatal: Unable to parse config file.\nOutput: %s" % err, False)
		do_error("Probably the wrong file was downloaded or the target config file wasn't found.", False)
		do_error("Please try again later, and if problem persists, report this as bug.")

	# check first if out there is something newer
	if config.has_option("General", "version"):
		vers = config.getfloat("General", "version")
		if vers > float(__version__):
			do_error("", False)
			do_error("Looks like you have an older version. Please download a newer version and try again.", False)
			do_error("You can find the latest version at 'http://equinox-project.org/netinstall'", False)
			do_error("")

	if config.has_option("General", "patches"):
		patches_url = config.get("General", "patches")

	# something we must have
	if not config.has_option("General", "mirrors"):
		do_error("Unable to find 'mirrors' section")

	if not config.has_option("General", "modules"):
		do_error("Unable to find 'modules' section")

	mirrors_url = config.get("General", "mirrors").split("\n")
	modules     = config.get("General", "modules").split(",")

	# remove spaces
	mirrors_url = [i.strip() for i in mirrors_url]
	modules = [i.strip() for i in modules]

	modules_objects = []

	# now parse each secion
	for i in modules:
		m = Module()
		m.name = i

		# mandatory keys
		if not config.has_option(i, "package"):
			do_error("Module '%s' is missing a 'package' section" % i)
		else:
			m.package = config.get(i, "package").strip('"')

		if not config.has_option(i, "checksum"):
			do_error("Module '%s' is missing a 'checksum' section" % i)
		else:
			m.checksum = config.get(i, "checksum").strip('"')

		# optional keys
		if config.has_option(i, "no_configure"):
			m.no_configure = config.getboolean(i, "no_configure")

		if config.has_option(i, "configure_flags"):
			m.configure_flags = config.get(i, "configure_flags").strip('"')

		if config.has_option(i, "configure_cmd"):
			m.configure_cmd = config.get(i, "configure_cmd ").strip('"')

		if config.has_option(i, "compile_cmd"):
			m.compile_cmd = config.get(i, "compile_cmd").strip('"')

		if config.has_option(i, "install_cmd"):
			m.install_cmd = config.get(i, "install_cmd").strip('"')

		if config.has_option(i, "skip_if_found"):
			m.skip_if_found = config.get(i, "skip_if_found").strip('"')

		if config.has_option(i, "url"):
			m.url = config.get(i, "url").strip('"')

		# this depends on global 'patches' key; if not existing, from where to fetch
		# the  patches then ;)
		if config.has_option(i, "patch"):
			if not patches_url:
				do_error("Module '%s' needs to be patched, but global patches url is not given" % i)
			m.patch = config.get(i, "patch").strip('"')

		# add it to the list if possible
		if m.skip_if_found and in_path(m.skip_if_found):
			do_message("Skipping '%s' since the command '%s' is found" % (m.name, m.skip_if_found), True)
			continue
		else:
			modules_objects.append(m)

	return modules_objects

def validate_md5sum(module):
	""" Compute md5 checksum and compare it to the existing one """
	if not file_exists(module.package):
		return False

	m = md5.new()
	f = open(module.package).read()
	m.update(f)
	return (m.hexdigest() == module.checksum)

def decompress_file(file):
	""" Decompress file using system tools. Return a directory name.  """
	should_extract = True

	cmd     = None
	tarname = None
	dirname = None

	stamp_file = None
	stamp_filename = ".netinstall_extract_stamp"

	if file.endswith(".tar.bz2"):
		tarname = file[:-4] # remove extension
		cmd = "bunzip2"
	elif file.endswith(".tar.gz"):
		tarname = file[:-3] # remove extension
		cmd = "gunzip"
	elif file.endswith(".tgz"):
		tarname = "%s.tar" % file[:-4] # files with .tgz extension are the same as .tar.gz
		cmd = "gunzip"
	else:
		do_error("Unable to guess '%s' file type. Try to remove this file and run this script again" % file)

	# before we do actual extracting, try to be a smart first; try first to see if tar file exists; if does
	# find directory entry and see if timestamp of .tar file was changed, by checking in dir/.netinstall_extract_stamp
	if file_exists(tarname):
		try:
			should_extract = False
			tarobj = tarfile.open(tarname, "r")
		except IOError:
			# we can't open it, go the hard way
			should_extract = True

		# if there is no need to extract the file, just find the first entry; it is expected to be a directory
		if not should_extract:
			first = tarobj.next()

			if first.isdir():
				dirname = first.name
				tar_ctime = os.stat(tarname).st_ctime

				stamp_file = "%s/%s" % (dirname, stamp_filename)

				if file_exists(stamp_file):
					s = open(stamp_file).readline()
					# real check
					if tar_ctime <= float(s):
						should_extract = False
			else:
				# first entry is not a directory
				should_extract = True

	if not should_extract:
		do_message("Archive %s fully extracted. Skipping..." % file)
		return dirname

	# from here we proceed with extraction; first remove whateve was .tar file since bunzip2
	# complains about it
	file_remove(tarname)

	# call gunzip/bunzip2
	os.system("%s %s" % (cmd, file))

	# TODO: duplication with above code
	try:
		tarobj = tarfile.open(tarname, "r")
	except IOError:
		do_error("Unable to correctly open '%s' as tar archive" % tarname)

	first = tarobj.next()
	if not first or not first.isdir():
		do_error("Expected directory as the first entry in this archive. Please report this as bug in the package")

	dirname = first.name
	stamp_file = "%s/%s" % (dirname, stamp_filename)
	tar_ctime = os.stat(tarname).st_ctime

	# extracting; do not call extractall() from TarFile since it is recently added
	os.system("tar -xpf %s" % tarname)

	# try to write the stamp
	try:
		f = open(stamp_file, "w")
		f.write("%f\n" % tar_ctime)
		f.close()
	except IOError:
		pass

	# strip ending slashes
	dirname = dirname.strip("/")
	return dirname


def fetch_module(module):
	"""Handles downloading assuring download were succedded. Also downloads it's patches if they exists"""
	# file is already downloaded
	if validate_md5sum(module):
		return

	got_file = False

	do_message("Downloading %s..." % module.package, True)

	# use 'url' if module provides it, skipping global mirrors_url
	if module.url:
		urls = [module.url]
	else:
		urls = mirrors_url

	for mirror in urls:
		path = "%s/%s" % (mirror, module.package)
		download_from(path, module.package)	

		# check if the file is correct
		if validate_md5sum(module):
			got_file = True
			break
		else:
			# remove what we downloaded (e.g. if sourceforge mirror does not has the file, it will
			# return html page and urllib will download it)
			file_remove(module.package)	

	if not got_file:
		do_error("Unable to download '%s' package. Please try again" % module.package)

	# now, check for patches
	if module.patch and patches_url:
		path = "%s/%s" % (patches_url, module.patch)

		do_message("Getting the patch for %s..." % module.package, True)
		download_from(patch, module.patch)

def extract_compile_and_install_module(module):
	"""Extract, patch, compile and install given package."""

	do_message("Extracting %s..." % module.package, True)

	dirname = decompress_file(module.package)
	# assure we have something
	assert(dirname != None)

	# do actual patching	
	if module.patch:
		if not file_exists(module.patch):
			do_error("Fatal: module patch was downloaded, but can't be found. Please try again")
		do_message("Patching %s..." % module.package, True)
		os.system("patch -t -p0 < %s" % module.patch)

	# top directory, so we know how to return
	top_dir = os.getcwd()
	# go in this directory
	os.chdir(dirname)

	do_message("Compiling %s..." % module.name, True)

	# run configure if 'no_configure' wasn't true
	if not module.no_configure:
		ret = os.system("%s %s" % (module.configure_cmd, module.configure_flags))
		if ret > 0:
			do_error("configure failed, reciving '%i' from the shell. There should be some output, right :-)" % ret)

	# compile
	ret = os.system(module.compile_cmd)
	if ret > 0:
		do_error("Compilation failed, reciving '%i' from the shell. There should be some output, right :-)" % ret)

	# install
	ret = os.system(module.install_cmd)
	if ret > 0:
		do_error("Installation failed, reciving '%i' from the shell. There should be some output, right :-)" % ret)

	# return where we started
	os.chdir(top_dir)

def check_prerequisites(check_for_root):
	"""Mandatory things before we do anything useful."""
	for tool in ["gunzip", "bunzip2", "patch"]:
		if not in_path(tool):
			do_error("Unable to find '%s' tool. Please install it first and start this tool again." % tool)

	if check_for_root and not os.getuid() == 0:
		do_error("You must be a root to run this tool. Since some packages depends on each other", False)
		do_error("they must be system wide installed. On other hand, if you are not sure what this script", False)
		do_error("can do, you can always check it's source code or directly ask developers.", False)
		do_error("", False)
		do_error("NOTE: always download this script from http://equinox-project.org, NOT from ANY other site.")

def help():
	print "Usage: netinstall [OPTIONS]" 
	print "Download, compile and install EDE with a single command :-)" 
	print ""
	print "Options:" 
	print "   --help                  this help" 
	print "   --version               script version" 
	print ""
	print "   --module-info   [NAME]  display information about [NAME] module"
	print "   --show-modules          list modules that will be compiled" 
	print "   --build-dir     [NAME]  directory where modules will be downloaded and compiled (default is 'build')"
	print "   --config        [NAME]  use [NAME] as main config file (default is 'netinstall.cfg')"
	print "   --config-local  [NAME]  use local config (only for debugging)"
	print "   --no-root-check         do not check if script was started as root (only for debugging)"
	print ""
	print "Report bugs at <http://bugs.equinox-project.org>."

def main():
	show_modules = False
	module_name  = None
	build_dir    = "build"
	config_name  = "netinstall.cfg"
	config_local = None
	check_for_root = True

	if len(sys.argv) > 1:
		try:
			import getopt
			opts, args = getopt.getopt(sys.argv[1:], "h", 
					["help", "version", "show-modules", "module-info=", "build-dir=", "config=", 
						"config-local=", "no-root-check"])
		except getopt.GetoptError, err:
			print "Bad option; rerun 'netinstall --help' for command details"
			return

		for o, a in opts:
			if o == "--help" or o == "-h":
				help()
				return
			if o == "--version":
				print __version__
				return
			if o == "--show-modules":
				show_modules = True
			elif o == "--module-info":
				module_name = a
			elif o == "--build-dir":
				build_dir = a
			elif o == "--config":
				config_name = a
			elif o == "--config-local":
				config_local = a
			elif o == "--no-root-check":
				check_for_root = False

	# do prerequisites first
	check_prerequisites(check_for_root)

	# get the config first and read it
	if config_local:
		config_name = config_local

	# in case suffix wasn't added, add it
	if not config_name.endswith(".cfg"):
		config_name += ".cfg"

	modules = fetch_and_parse_config(config_name, config_local != None)

	# create build directory and go in it
	try:
		os.makedirs(build_dir)
	except OSError, (errno, strerror):
		# 17 means directory already exists and that is ok
		if errno != 17:
			do_error("Unable to create directory %s (%s)" % (build_dir, strerror))

	# a directory where we started; full path is needed so we can return to it at the end
	starting_dir = os.getcwd()

	# go into build directory
	os.chdir(build_dir)

	# show a list of modules
	if show_modules:
		for i in modules:
			i.print_short_info()
		return

	# show module details
	if module_name:
		found = False

		for i in modules:
			if i.name == module_name:
				i.print_details()
				found = True
				break

		if not found:
			do_error("Module '%s' wasn't found" % module_name)
		return

	# or, do the main job; first download all packages
	for i in modules:
		fetch_module(i)

	# by now we are sure all files are downloaded correctly so we can
	# proceed to compile and install each of them
	for i in modules:
		extract_compile_and_install_module(i)

	# return where we started
	os.chdir(starting_dir)

if __name__ == "__main__":
	main()
