#
# $Id$
#
# Part of Equinox Desktop Environment (EDE).
# Copyright (c) 2000-2007 EDE Authors.
#
# This program is licensed under terms of the 
# GNU General Public License version 2 or newer.
# See COPYING for details.

SUFSHAREDLIB = ".so" ;

# StaticLibrary [lib-name] : [source-files] : [flags] ;
rule StaticLibrary
{
	local objects = [ FGristFiles $(>:S=$(SUFOBJ)) ] ;
	C++FLAGS on $(objects) = [ on $(objects) return $(C++FLAGS) ] $(3) ;
	CCFLAGS on $(objects) = [ on $(objects) return $(CCFLAGS) ] $(3) ;

	Library $(<) : $(>) ;
}

# Not used (althought it do the job) since MainFromObjects defines
# 'exe' target ('jam exe') which will build the library; I want 'lib' target :-P
#rule SharedLibraryFromObjects
#{
#	local shlib = $(1) ;
#	# In case path be part of $(shlib), gcc will set bad soname
#	# so it must be removed
#	local shlib_only = $(1:D=) ;
#
#	MainFromObjects $(shlib) : $(2) ;
#	LINKFLAGS on $(shlib) = [ on $(shlib) return $(LINKFLAGS) ] 
#		-shared -Wl,-soname,\"$(shlib_only)\" $(3) ;
#}

rule SharedLibraryFromObjects
{
	if ! $(UNIX) {
		Echo "Dynamic libraries can't be built on this OS now" ;
		return ;
	}

	local s t t_only ;

	t = $(1) ;
	s = [ FGristFiles $(2) ] ;

	# Rip directory part from target because this will
	# be passed to compiler as soname
	t_only = $(t:D=) ;

	# if given suffix, skip it; otherwise add SUFSHAREDLIB
	if ! $(t:S) {
		t = $(t:S=$(SUFSHAREDLIB)) ;
	}

	Depends lib : $(t) ;

	# This is used if library already does not have a path
	if ! $(t:D) {
		MakeLocate $(t) $(t)($(s:BS)) : $(LOCATE_TARGET) ;
	}

	# FIXME: option 'on $(t) return $(LINKLIBS)' can be re-used
	# instead $(3) parameter so [opt-linklibs] are not needed. Check this.
	LINKLIBS on $(t) = [ on $(t) return $(LINKLIBS) ] -shared -Wl,-soname,\"$(t_only)\" $(3) ;

	# Let target is dependant on source
	Depends $(t) : $(s) ;

	Link $(t) : $(s) ;
	Clean clean : $(t) ;
}

# SharedLibrary [libname] : [sources] : [opt-linklibs] ;
# Creates shared library [libname] from [sources]. If [opt-linklibs] are provided,
# library will be linked with them (they _must_ be in form -lfoo which will be directly
# passed to compiler).
#
# Note: ftjam in later versions provide rule with the same name, althought it calls
# libtool in the background. The way jam works, selecting latest redefined rules, ftjam's
# will be overriden with this.
rule SharedLibrary
{
	local shlib = $(1) ;
	local src = $(2) ;
	local objects = $(src:S=$(SUFOBJ)) ;

	SharedLibraryFromObjects $(shlib) : $(objects) : $(3) ;
	Objects $(src) ;
}

# SharedLibraryVersioned [libname] : [sources] : [opt-linklibs] : [opt-version] : ["nolink"] ;
# Creates versioned shared library (foo.so.[version]) which is often library naming
# on unix platforms. If [opt-version] is not given, it is like calling SharedLibrary only.
# By default it will create, besides [libname], ".so" symlink to it too. If "nolink" is given
# as 5 parameter, it will skip symlink creation.
rule SharedLibraryVersioned
{
	if $(4) {
		local target target_dir symlink versioned ;

		# Set .so.version extension
		versioned = "$(SUFSHAREDLIB).$(4)" ;

		# Jam is not smart about ripping suffixes so cases 'foo.so.2.0' 	
		# will produce 'foo.so.2'. We must hope that provided [libname] does _not_
		# have full name or everything will be screwed up (no facility in jam to check this).
		# With good hopes, we set first full target name and it's link abbreviation.
		target = $(1:S=$(versioned)) ;
		symlink = $(1:S=$(SUFSHAREDLIB)) ;
		SharedLibrary $(target) : $(2) : $(3) ;
	
		# Create symlink
		if $(5) != "nolink" {
			# copy target directory or symlink will be created
			# from place where jam is called
			LOCATE on $(symlink) = [ on $(target) return $(LOCATE) ] ;

			Depends lib : $(symlink) ;

			SymLink $(symlink) : $(target) ;
			Clean clean : $(symlink) ;
		}
	} else {
		SharedLibrary $(1) : $(2) : $(3) ;
	}
}
