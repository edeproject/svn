#
# $Id$
#
# Part of Equinox Desktop Environment (EDE).
# Copyright (c) 2000-2007 EDE Authors.
#
# This program is licensed under terms of the 
# GNU General Public License version 2 or newer.
# See COPYING for details.

SUFSHAREDLIB = ".so" ;

# StaticLibrary [lib-name] : [source-files] ;
rule StaticLibrary
{
	Library $(<) : $(>) ;
}

rule SharedLibraryFromObjects
{
	if ! $(UNIX) {
		Echo "Dynamic libraries can't be built on this OS now" ;
		return ;
	}

	local s t t_only ;

	t = $(1) ;
	s = [ FGristFiles $(2) ] ;

	# Rip directory and grist parts from target because this will
	# be passed to compiler as soname
	t_only = $(t:D=:G=) ;

	# if given suffix, skip it; otherwise add SUFSHAREDLIB
	if ! $(t:S) {
		t = $(t:S=$(SUFSHAREDLIB)) ;
	}

	LocalDepends lib : $(t) ;

	# This is used if library already does not have a path
	if ! $(t:D) {
		MakeLocate $(t) $(t)($(s:BS)) : $(LOCATE_TARGET) ;
	}

	LINKLIBS on $(t) = -shared -Wl,-soname,\"$(t_only)\" [ on $(t) return $(LINKLIBS) ] ;

	# Let target is dependant on source
	LocalDepends $(t) : $(s) ;

	Link $(t) : $(s) ;
	LocalClean clean : $(t) ;
}

# SharedLibrary [libname] : [sources] ;
# Creates shared library [libname] from [sources].
#
# Note: ftjam in later versions provide rule with the same name, althought it calls
# libtool in the background. The way jam works, selecting latest redefined rules, ftjam's
# will be overriden with this.
rule SharedLibrary
{
	local shlib = $(1) ;
	local src = $(2) ;
	local objects = [ FGristFiles $(src:S=$(SUFOBJ)) ] ;

	CCFLAGS on $(objects) += -fPIC ;
	C++FLAGS on $(objects) += -fPIC ;

	SharedLibraryFromObjects $(shlib) : $(objects) ;
	Objects $(src) ;
}

# SharedLibraryVersioned [libname] : [sources] : [opt-version] : ["nolink"] ;
# Creates versioned shared library (foo.so.[version]) which is often library naming
# on unix platforms. If [opt-version] is not given, it is like calling SharedLibrary only.
# By default it will create, besides [libname], ".so" symlink to it too. If "nolink" is given
# as 4 parameter, it will skip symlink creation.
rule SharedLibraryVersioned
{
	if $(3) {
		local target target_dir symlink versioned ;

		# Set .so.version extension
		versioned = "$(SUFSHAREDLIB).$(3)" ;

		# Jam is not smart about ripping suffixes so cases 'foo.so.2.0' 	
		# will produce 'foo.so.2'. We must hope that provided [libname] does _not_
		# have full name or everything will be screwed up (no facility in jam to check this).
		# With good hopes, we set first full target name and it's link abbreviation.
		target = $(1:S=$(versioned)) ;
		symlink = $(1:S=$(SUFSHAREDLIB)) ;
		SharedLibrary $(target) : $(2) ;
	
		# Create symlink
		if $(4) != "nolink" {
			# copy target directory or symlink will be created
			# from place where jam is called
			LOCATE on $(symlink) = [ on $(target) return $(LOCATE) ] ;

			LocalDepends lib : $(symlink) ;

			SymLink $(symlink) : $(target) ;
			LocalClean clean : $(symlink) ;
		}
	} else {
		SharedLibrary $(1) : $(2) ;
	}
}
